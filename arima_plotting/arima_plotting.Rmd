---
title: 'Multiple TS plots'
author: 'Jay Achar'
date: "`r Sys.time()`"
output:
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE)
suppressMessages(library(tidyverse))
library(here)
library(forecast)
library(ggdist)
library(patchwork)
```

```{r source-functions}
files <- list.files(here("R"))
walk(files,
     ~source(here("R", .x)))
```

# Important

I've noticed these parsing errors when reading in the data. I haven't looked through
them, but this would be important to check before finalizing things.

```{r read-in-data}
raw <- read_data("notifications")
```

## Define constants

It's often helpful to define standard variables that shouldn't change
at the top of your script. It's then easy to change later if you want to
re-run an analysis and also to see quickly what has been applied.

```{r define-constants}
# returns a list of constants
const <- constants()
```

```{r define-functions}
extract_model_fit <- function(models, param) {
  map_dbl(models, 
          ~ .x[[param]]) %>% sum()
}

extract_model_params <- function(models) {
  map(models, 
      ~ c(length(.x$model$phi), length(.x$model$Delta), length(.x$model$theta)))
}
```


## Data preparation

I tend to do all of my data preparation at the beginning. This might require
that you move later data cleaning tasks to this area, but having everything
mixed up is hard to work through for others looking at your code.

Here, I've created two lists of data frames - **wide** and **long**.
Their names tells me about their structure and the data frame names
(**country** and **region**) also help others to know what is contained.

```{r generate-data-structures}
dd <- prepare_data(raw, const = const)
```

```{r aggregate}
region_df <- dd$long$region %>% 
  filter(year >= 2014,
         age_group != "014") %>%  
  mutate(age_group = factor(age_group, levels = c("04", "514", "15plus"),
                            ordered = TRUE)) %>% 
  group_by(g_whoregion, age_group, year) %>% 
  summarise(cases = sum(cases, na.rm = TRUE))
```


## Arima modelling

I'll use nested list columns here to retain my origina data structure. Working with
long data is far easier than wide data so I'll start with that.

Note how I've nested the data before training models. This creates list columns
which contain our models and forecasts against columns that identify what they are.

Using iteration tools - e.g. the `purrr` package, simplifies all of this and reduces
the amount of code. This makes it easier to follow and reduces the potential for typos
to occur.

```{r arima-modelling}
# sorry for the confusing code here - the purpose is to remove the
# output created by the auto.arima function since it clutters the
# HTML output of the report.

ts_model_forecast <- function(model_fitting_function) {
        sink("/dev/null")
arima_models <- region_df %>%
        # remove 2020
        filter(year < 2020) %>%
        # nest data for each group of interest
        group_by(g_whoregion, age_group) %>% 
        nest() %>%
        # convert to time series = list-column
        mutate(ts = map(data, function(series) {
                series %>%
                        # remove year variable prior to converting to TS
                        select(-year) %>%
         ts(start = 2014, frequency = 1)
        })) %>%
        # fit arima.auto model to each groups data
        mutate(arima_model = map(ts, model_fitting_function)
                                 
                                 
               ) %>% 
        # run forecast for 2020 on each group
        mutate(forecast = map(arima_model,
                              ~ forecast(.x, h = 1)))
sink()
return(arima_models)
}

arima_models <- ts_model_forecast(
  function(x) {
    forecast::auto.arima(
    x,
    d = 1,
    D = 1,
    stepwise = FALSE,
    approximation = FALSE,
    trace = FALSE
  )
  }
)

# fixed_models <- ts_model_forecast(
#   function(x) {
#     Arima(
#       x,
#       order = c(3, 0, 1),
#       include.drift = TRUE
#     )
#   }
# )


```

## Plotting

This is a little complex...I'll try and give a thorough description of what has
been done.

Essentially there are two data frames being used by `ggplot` to create
each graphic.

The first data frame includes all of the years and cases from the original data:

```{r list-ts-data}
# create ts_df list
ts_list <- region_df %>%
  filter(age_group != "014") %>%
  group_by(age_group) %>%
  group_split()
```

```{r}
head(ts_list[[1]])
```

You can see that the data frame is specific to a sex/age group. There should
therefore be 8 data frames in this `ts_list` represting each unique combination
of sex and age group.

```{r list-forecast-data}
forecast_list <- arima_models %>%
  filter(age_group != "014") %>% 
        group_by(age_group) %>%
        group_split() %>%
        map(
                function(group) {
                        data.frame(
                            region = group$g_whoregion,
                year = 2020,
                point = as.numeric(map(group$forecast, ~ .x$mean)),
                lower95 = as.numeric(map(group$forecast, ~ .x$lower[2])),
                upper95 = as.numeric(map(group$forecast, ~ .x$upper[2]))
                        )
                }
        )
```

The second data frame includes the 2020 prediction information. This is grouped
in the same was as the previous data frame:

```{r}
head(forecast_list[[1]])
```

Finally, these two lists of data frames are iterated over using `purrr::map2()`
to create a list of ggplot objects. An alternative would be to add
a call to `ggsave` within each iteration and use `purrr::walk2` instead
of `purrr::map2`. This save the ggplots automatically to disk.

```{r prepare-ribbon-df, echo = FALSE}
# create ribbon data frame
ribbon_df <- map2(ts_list,

     function(ts, forecast) {
       ts %>% 
        filter(year == 2019) %>% 
        mutate(lower95 = cases,
               upper95 = cases) %>% 
        select(region = g_whoregion, 
               year,
               point = cases, 
               everything(), -age_group) %>% 
        bind_rows(forecast)
     })
```


```{r ts-plots }
arima_plots <- pmap(list(ts_list,
     forecast_list,
     ribbon_df),
     function(ts, forecast, ribbon) {
       ggplot(ts,
              aes(x = year)) +
         geom_line(aes(y = cases,
                       color = g_whoregion)) +
         geom_point(aes(y = cases,
                        color = g_whoregion),
                    size = 1) +
         geom_pointinterval(
           data = forecast,
           aes(
             x = year,
             y = point,
             ymin = lower95,
             ymax = upper95,
             color = region
           ),
           shape = 4,
           size = 2,
           orientation = "vertical"
           # position = position_dodgejust(width = 0.3)
         ) +
         geom_ribbon(
           data = ribbon,
           mapping = aes(
             ymin = lower95,
             ymax = upper95,
             group = region,
             fill = region
           ),
           alpha = 0.3
         ) +
         geom_line(
           data = ribbon,
           mapping = aes(x = year,
                         y = point,
                         group = region,
                         color = region),
           linetype = "dashed"
         ) +
         scale_color_discrete(guide = "none") +
         scale_fill_discrete(guide = "none") +
         scale_y_sqrt() +
         labs(x = "Year",
              y = "Cases (sqrt transformed)",
              fill = "WHO Region",
              title = paste0(unique(ts$age_group))) +
         theme_minimal()
       
     }) %>% 
  wrap_plots(ncol = 3) +
  scale_fill_discrete() 

ggsave(here::here("figures/main/main_arima_plots.png"),
       arima_plots,
       width = 15,
       height = 8)

arima_plots

```



## Calculate model fit

```{r}
safe_arima <- safely(Arima)

calculate_model_fit <- function(model_order, 
                                drift = FALSE,
                                fit_param = "aic") {
  arima_models %>%
    mutate(new_model = map(ts,
                           ~ safe_arima(.x,
                                   order = model_order,
                                   include.drift = drift))) %>%
    pull(new_model) %>% 
    keep(function(model) is.null(model$error)) %>% 
    map(~ pluck(.x, "result"))
}

params <- list(a = c(0, 1, 2, 3), b = c(0, 1, 2), c = c(0, 1, 2, 3), drift = c(TRUE, FALSE))
all_params <- do.call(expand_grid, params) %>% 
  filter(!(b >= 2 & drift == TRUE))


model_performance_metrics <- c("aic", "aicc", "bic")
metrics <- map(model_performance_metrics, function(metric) {
  
  all_params %>% 
  mutate(models = pmap(list(a, b, c, drift),
                       ~ calculate_model_fit(c(..1, ..2, ..3),
                                             drift = ..4))) %>% 
  mutate(model_count = map_int(models, length),
         sum = map_dbl(models, ~ extract_model_fit(.x, param = metric)),
         mean = sum / model_count) %>% 
  arrange(mean)
}) %>% set_names(model_performance_metrics) %>% bind_rows(.id = "metric")


```

## Plot mean model metrics

```{r}
metrics %>% 
  mutate(d_lab = ifelse(drift == TRUE, "T", "F")) %>% 
  mutate(model_spec = factor(str_c(a, b, c, d_lab))) %>%
  filter(model_count == 18) %>% 
  filter(mean < 120) %>% 
  ggplot(aes(x = model_spec,
         y = mean,
         color = metric)) + 
  geom_point() +
  coord_flip() +
  theme_minimal()
```




## Next steps

The plots are raw - they will need titles, better colors and more formatting.
I wonder whether you might be able to do some of this using this same code structure.

Regarding the plots themselves, we should think carefully about the y-axes. Right
now they are defined by ggplot based on the data in each plot. This results in the lines
being in acceptable places on the canvas, but would make comparison of different
plots more challenging and potentially might lead the casual observer to the wrong conclusion.
